knitr::opts_chunk$set(echo = TRUE)
# Independent variable X
X <- c(1, 2, 3, 4)
# Create the design matrix with augmented intercept term
X_augmented <- cbind(rep(1, length(X)), X)
print("Design matrix X:")
print(X_augmented)
$$B = \begin{pmatrix} 1 & 2 \\ 2 & 4 \end{pmatrix}$$
$$B = \begin{pmatrix} 1 & 2 \\ 2 & 4 \end{pmatrix}$$
$B = \begin{pmatrix} 1 & 2 \\ 2 & 4 \end{pmatrix}$
$\mathbf{X}$ $\begin{pmatrix} 1 & 2 \\ 2 & 4 \end{pmatrix}$
# Gotta load to roll
pacman::p_load(tidyverse)
# We can define some matrices like this
matrix1 <- matrix(seq(1,10, by = 1),
ncol = 2)
matrix2 <- matrix(seq(1,10, by = 1),
nrow = 2)
# Check dimensions using dim()
dim(matrix1)
dim(matrix2)
# By the m x n / n x p rule (or saying "5x2 premultiplied by 2x5"), we see the final matrix will be of dimensions 5x5
matrix1 %*% matrix2
# Similarly, we can say that 2x5 premultiplied by 5x2 = 2x2
matrix2 %*% matrix1
# If we have this matrix
matrix1
# We can transpose using t()
t(matrix1)
# We can use solve() to find the inverse of a matrix (but this will give an error message)
solve(matrix1)
knitr::opts_chunk$set(echo = TRUE)
# your code goes here
# your code here
# You can use the coefs from the previous regression model calculation in F1, and X_design and Y are defined as in F1 as well for this one
# your code here
# ESS: Explained Sum of Squares
# your code here
# RSS: Residual Sum of Squares
# your code here
# Gotta load to roll
pacman::p_load(tidyverse)
# We can define some matrices like this
matrix1 <- matrix(seq(1,10, by = 1),
ncol = 2)
matrix2 <- matrix(seq(1,10, by = 1),
nrow = 2)
# Check dimensions using dim()
dim(matrix1)
dim(matrix2)
# By the m x n / n x p rule (or saying "5x2 premultiplied by 2x5"), we see the final matrix will be of dimensions 5x5
matrix1 %*% matrix2
# Similarly, we can say that 2x5 premultiplied by 5x2 = 2x2
matrix2 %*% matrix1
# If we have this matrix
matrix1
# We can transpose using t()
t(matrix1)
# We can use solve() to find the inverse of a matrix (but this will give an error message)
solve(matrix1)
# Let's multiply it by its own transposed
matrix_square <- t(matrix1) %*% matrix1
# And then let's try to find the inverse
solve(matrix_square) # Success!
# Multiply them in different orders to see the different results
t(matrix1) %*% matrix1
matrix1 %*% t(matrix1)
solve(t(matrix1) %*% matrix1)
matrix3 <- matrix( c(1,2,3,6) ,ncol = 2, nrow = 2)
matrix3
solve(matrix3)
det(matrix3)
